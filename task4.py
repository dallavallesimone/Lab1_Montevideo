# -*- coding: utf-8 -*-
"""Untitled

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jj3bfJ1Tii8Mz5EXCWNcoXO-STp-Tsn0
"""

import numpy as np
import sys

a = np.array([[1,1],[0,1]]) 

print("Array a:")
print(a)
ainv = np.linalg.inv(a) 

print("Inverse of a:")
print(ainv)
print("id:")
print(np.array(np.around(np.dot(a, ainv))).astype('int'))

#zeors_array = np.zeros( (32, 32) )

A = []
with open("matrix.csv", 'r') as f:
  lines = f.read().split('\n')
# Get x and y values from each line and append to self.data
for line in lines:
  value = int(line)
  A.append(value)
A_mat = np.mat(A)
A_mat = A_mat.reshape(32,32)
print("real start")
print("A_mat:", A_mat)


B = []
with open("matrix_b.csv", 'r') as f:
  lines = f.read().split('\n')
# Get x and y values from each line and append to self.data
for line in lines:
  value = int(line)
  B.append(value)
#B_mat = np.mat(B)
B_mat = np.mat(B)
B_mat = B_mat.reshape(32,32)
B_mat = B_mat % 2
B_mat = B_mat.astype('bool')

det_A = np.linalg.det(A_mat)
#print("det of A:", det_A)
ainv = np.linalg.inv(A_mat) 
ai = np.rint(ainv * det_A) % 2

#print("Inverse of a:")
#print(ainv)
#print("id:")
#print(np.array(np.around(np.dot(A_mat, ainv))).astype('int'))
#bin_ainv = np.remainder(np.around(np.array(ainv*det_A)), 2)
#print("mod1 ai:\n", ai)
#print("mod2 ai:\n", bin_ainv)
#A_mat = (np.array(A_mat)).astype('bool')
#print("bin a:\n", A_mat)
#print("bin_ainv:\n", bin_ainv)
#print("bool id:")
#print("should be id:\n", np.dot(A_mat, ai))


temp = np.around(np.array(inverse_a*det_A))
final_inverse_A = np.array(np.remainder(temp, 2))
print("binary inverse of A:",bin_ainv)

final_inverse_A = final_inverse_A.astype('bool')
A_mat = A_mat.astype('bool')
#print("ident:", np.dot(final_inverse_A, A_mat))
#print(final_inverse_A)

with open("KPApairsMontevideo_linear.hex", 'r') as f:
  lines = f.read().split('\n')
# Get x and y values from each line and append to self.data
spec = '{fill}{align}{width}{type}'.format(fill='0', align='>', width=32, type='b')
for line in lines:
  sample = line.split('\t')
  plaintext = str(format(int(sample[0], 16),spec))
  ciphertext = str(format(int(sample[1], 16),spec))
  plaintext = [plaintext[i:i+1] for i in range(0, len(plaintext), 1)];
  plaintext = [int(item) for item in plaintext]
  #plaintext = [bool(item) for item in plaintext]
  #print("plaintextbefore",plaintext)
  plaintext = np.array(plaintext)
  #print("plaintextafter",plaintext)
  plaintext = plaintext.astype('bool')
  ciphertext = [ciphertext[i:i+1] for i in range(0, len(ciphertext), 1)];
  ciphertext = [int(item) for item in ciphertext]
  #ciphertext = [bool(item) for item in ciphertext]
  ciphertext = np.array(ciphertext)
  #ciphertext = ciphertext.astype('bool')
  #print("plaintext",plaintext)
  #print("B", B_mat)

  k = np.dot(ciphertext^np.dot(plaintext,B_mat), ai) % 2
  print("k:\n", k)
  
  # compute key
  """
  prod = []
  # B * u
  for row in B_mat:
    #print("row:\n", row)
    temp = array_row & plaintext
    temp_sq = np.squeeze(temp)
    print("temp:\n", temp_sq)
    val = False
    for item in temp_sq:
      val = val ^ item
    print("val: ", val)
    prod.append(val)
  #print("prod:\n", prod)
  sys.exit()

  sum = np.logical_xor(ciphertext,prod)

  key = []
  for row in ai:
    temp = np.logical_and(row, ciphertext)
    val = False
    for item in temp:
      val = val ^ item
    key.append(val)
  print("key: ", key)"""

a = np.array([[1,  1],
               [0,  1]], dtype=bool)
b = np.array([[1,  1],
               [0,  1]], dtype=bool)

print(np.dot(a,b))